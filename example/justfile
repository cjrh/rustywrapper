# Example project commands
# Run from: example/

venv_dir := justfile_directory() / ".venv"
venv_python := venv_dir / "bin/python"

# export PYO3_PYTHON := venv_python
# export PYTHONPATH := shell(venv_python + ' -c "import site; print(site.getsitepackages()[0])"')

@default:
    just --list

# Python venv management
#
# This is a pickle. PyO3 works great with venvs, but only if the libpython
# shared library is in a standard location. If you use a system
# Python to create the venv, libpython nevertheless remains in a standard
# location and at runtime the linker has no problem finding it.
# The problem arises when you use a different pythonn distribution
# that does not have libpython accessible in a standard location.
# We're using uv, which has this problem. If we used uv to create
# the venv, then at runtime PyO3 would not be able to find libpython
# We could resolve the issue by setting LD_LIBRARY_PATH, but that
# is messy and error-prone. So instead we create the venv
# using the system Python, which works fine. All the other commands
# nevertheless use uv.
venv:
    /usr/bin/python3 -m venv --without-pip .venv

sync:
    uv sync

setup: venv sync
    @echo "Example environment ready!"

serve: venv sync
    # export PYO3_PYTHON := venv_python
    # export PYTHONPATH := shell(venv_python + ' -c "import site; print(site.getsitepackages()[0])"')
    PYO3_PYTHON={{venv_python}} \
        PYTHONPATH={{shell(venv_python + ' -c "import site; print(site.getsitepackages()[0])"')}}  \
        cargo run

build: venv sync
    PYO3_PYTHON={{venv_python}} cargo build

test-all: test-rust test-python test-async test-async-concurrency test-pool test-concurrency test-python-polars

test-rust:
    @echo "Testing Rust endpoints..."
    curl -s http://localhost:3000/rust/hello | jq
    curl -s -X POST http://localhost:3000/rust/echo \
        -H "Content-Type: application/json" \
        -d '{"name":"test"}' | jq

test-python:
    @echo "Testing Python in-thread endpoints..."
    curl -s http://localhost:3000/python/hello | jq
    curl -s -X POST http://localhost:3000/python/process \
        -H "Content-Type: application/json" \
        -d '{"data":"hello"}' | jq

test-async:
    @echo "Testing Python async endpoints..."
    curl -s http://localhost:3000/python/async/hello | jq
    curl -s "http://localhost:3000/python/async/sleep?duration=0.5" | jq
    curl -s http://localhost:3000/python/async/concurrent | jq
    curl -s "http://localhost:3000/python/async/timeout?timeout=2&delay=1" | jq

test-async-concurrency:
    #!/usr/bin/env bash
    set -euo pipefail
    # Set a local variable for the number of concurrent requests
    num_requests=10
    echo "Testing async concurrent request handling..."
    echo "Sending $num_requests async requests that each sleep 1 second..."
    echo ""

    start_time=$(date +%s.%N)

    # Send 10 concurrent async requests
    for i in {1..$num_requests}; do
        curl -s "http://localhost:3000/python/async/sleep?duration=1" > /tmp/async_task$i.json &
    done

    # Wait for all to complete
    echo "Waiting..."
    date
    wait
    echo "...Done."
    date

    end_time=$(date +%s.%N)
    elapsed=$(echo "$end_time - $start_time" | bc)

    echo "Total wall-clock time: ${elapsed}s"

    # Check if concurrent (should be ~1s for 10x1s tasks running concurrently)
    if (( $(echo "$elapsed < 2.5" | bc -l) )); then
        echo "✓ PASS: Async requests processed concurrently (< 2.5s for $num_requests requests)"
    else
        echo "✗ FAIL: Async requests not concurrent (expected < 2.5s, got ${elapsed}s)"
        exit 1
    fi

test-python-polars:
    curl -s http://localhost:3000/python/polars-demo | jq

test-pool:
    @echo "Testing Python process pool endpoints..."
    curl -s "http://localhost:3000/python/pool/squares?numbers=1,2,3,4,5" | jq
    curl -s -X POST http://localhost:3000/python/pool/compute \
        -H "Content-Type: application/json" \
        -d '{"numbers":[1,2,3,4,5]}' | jq

test-concurrency:
    #!/usr/bin/env bash
    set -euo pipefail
    num_requests=4
    echo "Testing concurrent request handling..."
    echo "Sending $num_requests requests that each sleep 1 second..."
    echo ""

    start_time=$(date +%s.%N)

    # Send concurrent requests
    for i in $(seq 1 "$num_requests"); do
        # curl -s "http://localhost:3000/python/async/sleep?duration=1" > /tmp/async_task$i.json &
        curl -s "http://localhost:3000/python/pool/slow?duration=1&task_id=$i" > "/tmp/task${i}.json" &
    done

    # Wait for all to complete
    echo "Waiting..."
    wait
    echo "...Done."

    end_time=$(date +%s.%N)
    elapsed=$(echo "$end_time - $start_time" | bc)

    echo "Results:"
    for i in $(seq 1 "$num_requests"); do
        echo "  Task $i: $(jq -c . /tmp/task$i.json)"
    done
    echo ""
    echo "Total wall-clock time: ${elapsed}s"

    # Check if concurrent (should be < 3s for 4x1s tasks)
    if (( $(echo "$elapsed < 3.0" | bc -l) )); then
        echo "✓ PASS: Requests processed concurrently (< 3s)"
    else
        echo "✗ FAIL: Requests processed sequentially (expected < 3s, got ${elapsed}s)"
        exit 1
    fi
